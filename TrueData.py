# -*- coding: utf-8 -*-
"""TrueData.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11FvbAr19SvRQC3nGMh-ZB_-RU19eyPz0
"""
import os
import requests
import gzip
import obspy
import numpy as np
import matplotlib.pyplot as plt

class TrueModel:
    """
    The base class for different types of true models.
    """

    class Marmousi1_Velocity:
        def __init__(self, vp_url='http://math.mit.edu/~rhewett/pysit/marmousi/velocity_rev1.segy.gz', output_filename='velocity_rev1.segy', max_depth_km=3.0, max_distance_km=16.0):
            """
            Initialize the Marmousi1 model with a URL to download the data, output filename, max depth, and max distance.

            Parameters:
            vp_url (str): URL for downloading the P-wave velocity model.
            output_filename (str): Name of the output file for the SEGY data.
            max_depth_km (float): Maximum depth in kilometers.
            max_distance_km (float): Maximum distance in kilometers.
            """
            self.vp_url = vp_url
            self.output_filename = output_filename
            self.max_depth_km = max_depth_km
            self.max_distance_km = max_distance_km
            self.vp_data = None

        def download_and_extract(self, verbose=True):
            """
            Download and extract the SEGY file.

            Parameters:
            verbose (bool): Whether to print detailed messages.
            """
            # Check if file already exists
            if os.path.exists(self.output_filename):
                if verbose:
                    print(f'File {self.output_filename} already exists, skipping download.')
                return

            # Download the file
            if verbose:
                print(f'Downloading {self.vp_url}...')
            try:
                response = requests.get(self.vp_url, stream=True)
                response.raise_for_status()
                with open(self.output_filename + '.gz', 'wb') as f:
                    f.write(response.content)
                if verbose:
                    print(f'Downloaded {self.output_filename}.gz')
            except requests.RequestException as e:
                print(f'Failed to download {self.vp_url}: {e}')
                return

            # Extract the file
            if verbose:
                print(f'Extracting {self.output_filename}.gz...')
            try:
                with gzip.open(self.output_filename + '.gz', 'rb') as f_in:
                    with open(self.output_filename, 'wb') as f_out:
                        f_out.write(f_in.read())
                if verbose:
                    print(f'Extracted {self.output_filename}')
            except OSError as e:
                print(f'Failed to extract {self.output_filename}.gz: {e}')
                return

            # Remove the gz file
            os.remove(self.output_filename + '.gz')
            if verbose:
                print(f'Removed {self.output_filename}.gz')

        def read_segy_file(self):
            """
            Read the SEGY file using obspy and store the velocity data.
            """
            try:
                segy = obspy.read(self.output_filename, format='SEGY')
                # Extract data from the traces
                self.vp_data = np.array([tr.data for tr in segy.traces])
            except Exception as e:
                self.vp_data = None

        def process_data(self):
            """
            Process the velocity data: flip vertically, rotate, and scale to realistic values.
            """
            if self.vp_data is not None:
                # Correct the orientation of the velocity model
                #self.vp_data = np.flipud(self.vp_data)  # Flip the data vertically

                # Rotate the velocity model data 90 degrees counterclockwise
                #self.vp_data = np.rot90(self.vp_data, k=3)  # Rotate 90 degrees counterclockwise

                # Scale the velocity values to a realistic range (e.g., multiply by 1000)
                self.vp_data = self.vp_data * 1000

        def plot_model(self):
            """
            Plot the P-wave velocity model.
            """
            if self.vp_data is not None:
                fig, ax = plt.subplots(figsize=(14, 6))

                # Plotting the data with the correct depth orientation (depth increases downward from 0 at the top)
                cax = ax.imshow(self.vp_data, cmap='jet', aspect='auto', origin='upper',
                                extent=[0, self.max_distance_km, self.max_depth_km, 0])

                # Adding the colorbar with better alignment
                cbar = fig.colorbar(cax, ax=ax, orientation='vertical', pad=0.02)
                cbar.set_label('P-wave Velocity (m/s)', fontsize=12)
                cbar.formatter.set_useOffset(False)  # Disable scientific notation
                cbar.update_ticks()

                # Axis labels and title
                ax.set_title('Marmousi1 P-wave Velocity Model', fontsize=14, loc='center', pad=10)
                ax.set_xlabel('Distance (Km)', fontsize=12, labelpad=10)
                ax.set_ylabel('Depth (Km)', fontsize=12, labelpad=10)

                # Adjust layout for better alignment of elements
                plt.tight_layout()
                plt.subplots_adjust(left=0.08, right=0.92, top=0.95, bottom=0.1)

                plt.show()

        def run(self):
            """
            Run the full sequence of downloading, extracting, reading, processing, and plotting the data.
            """
            self.download_and_extract()
            self.read_segy_file()
            self.process_data()
            self.plot_model()


    class Marmousi2_Velocity:
        def __init__(self, vp_url='http://www.agl.uh.edu/downloads/vp_marmousi-ii.segy.gz', output_filename='vp_marmousi-ii.segy', max_depth_km=3.0, max_distance_km=16.0):
            """
            Initialize the Marmousi2 model with a URL to download the data, output filename, max depth, and max distance.

            Parameters:
            vp_url (str): URL for downloading the P-wave velocity model.
            output_filename (str): Name of the output file for the SEGY data.
            max_depth_km (float): Maximum depth in kilometers.
            max_distance_km (float): Maximum distance in kilometers.
            """
            self.vp_url = vp_url
            self.output_filename = output_filename
            self.max_depth_km = max_depth_km
            self.max_distance_km = max_distance_km
            self.vp_data = None

        def download_and_extract(self, verbose=True):
            """
            Download and extract the SEGY file.

            Parameters:
            verbose (bool): Whether to print detailed messages.
            """
            # Check if file already exists
            if os.path.exists(self.output_filename):
                if verbose:
                    print(f'File {self.output_filename} already exists, skipping download.')
                return

            # Download the file
            if verbose:
                print(f'Downloading {self.vp_url}...')
            try:
                response = requests.get(self.vp_url, stream=True)
                response.raise_for_status()
                with open(self.output_filename + '.gz', 'wb') as f:
                    f.write(response.content)
                if verbose:
                    print(f'Downloaded {self.output_filename}.gz')
            except requests.RequestException as e:
                print(f'Failed to download {self.vp_url}: {e}')
                return

            # Extract the file
            if verbose:
                print(f'Extracting {self.output_filename}.gz...')
            try:
                with gzip.open(self.output_filename + '.gz', 'rb') as f_in:
                    with open(self.output_filename, 'wb') as f_out:
                        f_out.write(f_in.read())
                if verbose:
                    print(f'Extracted {self.output_filename}')
            except OSError as e:
                print(f'Failed to extract {self.output_filename}.gz: {e}')
                return

            # Remove the gz file
            os.remove(self.output_filename + '.gz')
            if verbose:
                print(f'Removed {self.output_filename}.gz')

        def read_segy_file(self):
            """
            Read the SEGY file using obspy and store the velocity data.
            """
            try:
                segy = obspy.read(self.output_filename, format='SEGY')
                # Extract data from the traces
                self.vp_data = np.array([tr.data for tr in segy.traces])
            except Exception as e:
                self.vp_data = None

        def process_data(self):
            """
            Process the velocity data: flip vertically, rotate, and scale to realistic values.
            """
            if self.vp_data is not None:
                # Correct the orientation of the velocity model
                self.vp_data = np.flipud(self.vp_data)  # Flip the data vertically

                # Rotate the velocity model data 90 degrees counterclockwise
                self.vp_data = np.rot90(self.vp_data, k=3)  # Rotate 90 degrees counterclockwise

                # Scale the velocity values to a realistic range (e.g., multiply by 1000)
                self.vp_data = self.vp_data * 1000

        def plot_model(self):
            """
            Plot the P-wave velocity model.
            """
            if self.vp_data is not None:
                fig, ax = plt.subplots(figsize=(14, 6))

                # Plotting the data with the correct depth orientation (depth increases downward from 0 at the top)
                cax = ax.imshow(self.vp_data, cmap='jet', aspect='auto', origin='upper',
                                extent=[0, self.max_distance_km, self.max_depth_km, 0])

                # Adding the colorbar with better alignment
                cbar = fig.colorbar(cax, ax=ax, orientation='vertical', pad=0.02)
                cbar.set_label('P-wave Velocity (m/s)', fontsize=12)
                cbar.formatter.set_useOffset(False)  # Disable scientific notation
                cbar.update_ticks()

                # Axis labels and title
                ax.set_title('Marmousi2 P-wave Velocity Model', fontsize=14, loc='center', pad=10)
                ax.set_xlabel('Distance (Km)', fontsize=12, labelpad=10)
                ax.set_ylabel('Depth (Km)', fontsize=12, labelpad=10)

                # Adjust layout for better alignment of elements
                plt.tight_layout()
                plt.subplots_adjust(left=0.08, right=0.92, top=0.95, bottom=0.1)

                plt.show()

        def run(self):
            """
            Run the full sequence of downloading, extracting, reading, processing, and plotting the data.
            """
            self.download_and_extract()
            self.read_segy_file()
            self.process_data()
            self.plot_model()


    class Marmousi1_Density:
        def __init__(self, rho_url='http://math.mit.edu/~rhewett/pysit/marmousi/density_rev1.segy.gz', output_filename='density_rev1.segy', max_depth_km=3.0, max_distance_km=16.0):
            """
            Initialize the Marmousi1 density model with a URL to download the data, output filename, max depth, and max distance.

            Parameters:
            rho_url (str): URL for downloading the density model.
            output_filename (str): Name of the output file for the SEGY data.
            max_depth_km (float): Maximum depth in kilometers.
            max_distance_km (float): Maximum distance in kilometers.
            """
            self.rho_url = rho_url
            self.output_filename = output_filename
            self.max_depth_km = max_depth_km
            self.max_distance_km = max_distance_km
            self.rho_data = None

        def download_and_extract(self, verbose=True):
            """
            Download and extract the SEGY file.

            Parameters:
            verbose (bool): Whether to print detailed messages.
            """
            # Check if file already exists
            if os.path.exists(self.output_filename):
                if verbose:
                    print(f'File {self.output_filename} already exists, skipping download.')
                return

            # Download the file
            if verbose:
                print(f'Downloading {self.rho_url}...')
            try:
                response = requests.get(self.rho_url, stream=True)
                response.raise_for_status()
                with open(self.output_filename + '.gz', 'wb') as f:
                    f.write(response.content)
                if verbose:
                    print(f'Downloaded {self.output_filename}.gz')
            except requests.RequestException as e:
                print(f'Failed to download {self.rho_url}: {e}')
                return

            # Extract the file
            if verbose:
                print(f'Extracting {self.output_filename}.gz...')
            try:
                with gzip.open(self.output_filename + '.gz', 'rb') as f_in:
                    with open(self.output_filename, 'wb') as f_out:
                        f_out.write(f_in.read())
                if verbose:
                    print(f'Extracted {self.output_filename}')
            except OSError as e:
                print(f'Failed to extract {self.output_filename}.gz: {e}')
                return

            # Remove the gz file
            os.remove(self.output_filename + '.gz')
            if verbose:
                print(f'Removed {self.output_filename}.gz')

        def read_segy_file(self):
            """
            Read the SEGY file using obspy and store the density data.
            """
            try:
                segy = obspy.read(self.output_filename, format='SEGY')
                # Extract data from the traces
                self.rho_data = np.array([tr.data for tr in segy.traces])
            except Exception as e:
                self.rho_data = None

        def process_data(self):
            """
            Process the density data: flip vertically, rotate, and scale to realistic values.
            """
            if self.rho_data is not None:
                # Correct the orientation of the density model
                #self.rho_data = np.flipud(self.rho_data)  # Flip the data vertically

                # Rotate the density model data 90 degrees counterclockwise
                #self.rho_data = np.rot90(self.rho_data, k=3)  # Rotate 90 degrees counterclockwise

                # Scale the density values to a realistic range (e.g., multiply by 1000)
                self.rho_data = self.rho_data * 1000

        def plot_model(self):
            """
            Plot the density model.
            """
            if self.rho_data is not None:
                fig, ax = plt.subplots(figsize=(14, 6))

                # Plotting the data with the correct depth orientation (depth increases downward from 0 at the top)
                cax = ax.imshow(self.rho_data, cmap='jet', aspect='auto', origin='upper',
                                extent=[0, self.max_distance_km, self.max_depth_km, 0])

                # Adding the colorbar with better alignment
                cbar = fig.colorbar(cax, ax=ax, orientation='vertical', pad=0.02)
                cbar.set_label('Density (kg/m^3)', fontsize=12)
                cbar.formatter.set_useOffset(False)  # Disable scientific notation
                cbar.update_ticks()

                # Axis labels and title
                ax.set_title('Marmousi1 Density Model', fontsize=14, loc='center', pad=10)
                ax.set_xlabel('Distance (Km)', fontsize=12, labelpad=10)
                ax.set_ylabel('Depth (Km)', fontsize=12, labelpad=10)

                # Adjust layout for better alignment of elements
                plt.tight_layout()
                plt.subplots_adjust(left=0.08, right=0.92, top=0.95, bottom=0.1)

                plt.show()

        def run(self):
            """
            Run the full sequence of downloading, extracting, reading, processing, and plotting the data.
            """
            self.download_and_extract()
            self.read_segy_file()
            self.process_data()
            self.plot_model()


    class Marmousi2_Density:
        def __init__(self, rho_url='http://www.agl.uh.edu/downloads/density_marmousi-ii.segy.gz', output_filename='density_marmousi-ii.segy', max_depth_km=3.0, max_distance_km=16.0):
            """
            Initialize the Marmousi2 density model with a URL to download the data, output filename, max depth, and max distance.

            Parameters:
            rho_url (str): URL for downloading the density model.
            output_filename (str): Name of the output file for the SEGY data.
            max_depth_km (float): Maximum depth in kilometers.
            max_distance_km (float): Maximum distance in kilometers.
            """
            self.rho_url = rho_url
            self.output_filename = output_filename
            self.max_depth_km = max_depth_km
            self.max_distance_km = max_distance_km
            self.rho_data = None

        def download_and_extract(self, verbose=True):
            """
            Download and extract the SEGY file.

            Parameters:
            verbose (bool): Whether to print detailed messages.
            """
            # Check if file already exists
            if os.path.exists(self.output_filename):
                if verbose:
                    print(f'File {self.output_filename} already exists, skipping download.')
                return

            # Download the file
            if verbose:
                print(f'Downloading {self.rho_url}...')
            try:
                response = requests.get(self.rho_url, stream=True)
                response.raise_for_status()
                with open(self.output_filename + '.gz', 'wb') as f:
                    f.write(response.content)
                if verbose:
                    print(f'Downloaded {self.output_filename}.gz')
            except requests.RequestException as e:
                print(f'Failed to download {self.rho_url}: {e}')
                return

            # Extract the file
            if verbose:
                print(f'Extracting {self.output_filename}.gz...')
            try:
                with gzip.open(self.output_filename + '.gz', 'rb') as f_in:
                    with open(self.output_filename, 'wb') as f_out:
                        f_out.write(f_in.read())
                if verbose:
                    print(f'Extracted {self.output_filename}')
            except OSError as e:
                print(f'Failed to extract {self.output_filename}.gz: {e}')
                return

            # Remove the gz file
            os.remove(self.output_filename + '.gz')
            if verbose:
                print(f'Removed {self.output_filename}.gz')

        def read_segy_file(self):
            """
            Read the SEGY file using obspy and store the density data.
            """
            try:
                segy = obspy.read(self.output_filename, format='SEGY')
                # Extract data from the traces
                self.rho_data = np.array([tr.data for tr in segy.traces])
            except Exception as e:
                self.rho_data = None

        def process_data(self):
            """
            Process the density data: flip vertically, rotate, and scale to realistic values.
            """
            if self.rho_data is not None:
                # Correct the orientation of the density model
                self.rho_data = np.flipud(self.rho_data)  # Flip the data vertically

                # Rotate the density model data 90 degrees counterclockwise
                self.rho_data = np.rot90(self.rho_data, k=3)  # Rotate 90 degrees counterclockwise

                # Scale the density values to a realistic range (e.g., multiply by 1000)
                self.rho_data = self.rho_data * 1000

        def plot_model(self):
            """
            Plot the density model.
            """
            if self.rho_data is not None:
                fig, ax = plt.subplots(figsize=(14, 6))

                # Plotting the data with the correct depth orientation (depth increases downward from 0 at the top)
                cax = ax.imshow(self.rho_data, cmap='jet', aspect='auto', origin='upper',
                                extent=[0, self.max_distance_km, self.max_depth_km, 0])

                # Adding the colorbar with better alignment
                cbar = fig.colorbar(cax, ax=ax, orientation='vertical', pad=0.02)
                cbar.set_label('Density (kg/m^3)', fontsize=12)
                cbar.formatter.set_useOffset(False)  # Disable scientific notation
                cbar.update_ticks()

                # Axis labels and title
                ax.set_title('Marmousi2 Density Model', fontsize=14, loc='center', pad=10)
                ax.set_xlabel('Distance (Km)', fontsize=12, labelpad=10)
                ax.set_ylabel('Depth (Km)', fontsize=12, labelpad=10)

                # Adjust layout for better alignment of elements
                plt.tight_layout()
                plt.subplots_adjust(left=0.08, right=0.92, top=0.95, bottom=0.1)

                plt.show()

        def run(self):
            """
            Run the full sequence of downloading, extracting, reading, processing, and plotting the data.
            """
            self.download_and_extract()
            self.read_segy_file()
            self.process_data()
            self.plot_model()

